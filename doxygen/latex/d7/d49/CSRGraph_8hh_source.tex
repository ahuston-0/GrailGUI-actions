\hypertarget{CSRGraph_8hh_source}{}\doxysection{CSRGraph.\+hh}
\label{CSRGraph_8hh_source}\index{src/visualcs/CSRGraph.hh@{src/visualcs/CSRGraph.hh}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{00002 \textcolor{preprocessor}{\#include <sys/stat.h>}}
\DoxyCodeLine{00003 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{00004 }
\DoxyCodeLine{00005 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include <limits>}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include <queue>}  \textcolor{comment}{// we don't have a queue, so use STL}}
\DoxyCodeLine{00010 }
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include "{}util/Ex.hh"{}}}
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include "{}util/Stack.hh"{}}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include "{}util/wtime.h"{}}}
\DoxyCodeLine{00014 \textcolor{preprocessor}{\#include "{}visualcs/Graph.hh"{}}}
\DoxyCodeLine{00015 }
\DoxyCodeLine{00016 \textcolor{keyword}{template} <\textcolor{keyword}{typename} VertexIndex\_t, \textcolor{keyword}{typename} EdgeIndex\_t, \textcolor{keyword}{typename} Weight\_t>}
\DoxyCodeLine{\Hypertarget{CSRGraph_8hh_source_l00017}\mbox{\hyperlink{classCSRGraph}{00017}} \textcolor{keyword}{class }\mbox{\hyperlink{classCSRGraph}{CSRGraph}} : \textcolor{keyword}{public} \mbox{\hyperlink{classGraph}{Graph}} \{}
\DoxyCodeLine{00018  \textcolor{keyword}{private}:}
\DoxyCodeLine{00019   \textcolor{keyword}{static} \textcolor{keyword}{inline} off\_t fsize(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* filename) \{}
\DoxyCodeLine{00020     \textcolor{keyword}{struct }stat st;}
\DoxyCodeLine{00021     \textcolor{keywordflow}{if} (stat(filename, \&st) == 0) \textcolor{keywordflow}{return} st.st\_size;}
\DoxyCodeLine{00022     \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{00023   \}}
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025   \textcolor{comment}{/*}}
\DoxyCodeLine{00026 \textcolor{comment}{    not using this yet. We can't figure out a convenient way to share the code}}
\DoxyCodeLine{00027 \textcolor{comment}{    between the three vectors, so it's cut and past in the load file for now}}
\DoxyCodeLine{00028 \textcolor{comment}{   */}}
\DoxyCodeLine{00029   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00030   \textcolor{keywordtype}{void} loadCSRFile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} filename[], uint64\_t fileLen) \{}
\DoxyCodeLine{00031     FILE* file = fopen(filename, \textcolor{stringliteral}{"{}rb"{}});}
\DoxyCodeLine{00032     \textcolor{keywordflow}{if} (file == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{throw} \mbox{\hyperlink{classEx}{Ex}}(\_\_FILE\_\_, \_\_LINE\_\_, \textcolor{stringliteral}{"{}Can't open"{}});}
\DoxyCodeLine{00033     T* csrVec = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00034 }
\DoxyCodeLine{00035     \textcolor{keywordflow}{if} (posix\_memalign((\textcolor{keywordtype}{void}**)\&csrVec, getpagesize(),}
\DoxyCodeLine{00036                        \textcolor{keyword}{sizeof}(T) * (fileLen + 1)))}
\DoxyCodeLine{00037       \textcolor{keywordflow}{throw} \mbox{\hyperlink{classEx}{Ex}}(\_\_FILE\_\_, \_\_LINE\_\_, \textcolor{stringliteral}{"{}posix\_memalign"{}});}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039     \textcolor{keywordtype}{size\_t} ret = fread(csrVec, \textcolor{keyword}{sizeof}(T), fileLen, file);}
\DoxyCodeLine{00040     assert(ret == fileLen);}
\DoxyCodeLine{00041     fclose(file);}
\DoxyCodeLine{00042 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{00043     adjLen = csrVec[vert\_count];}
\DoxyCodeLine{00044     std::cout << \textcolor{stringliteral}{"{}Expected edge count: "{}} << csrVec[vert\_count] << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{00045     assert(tmp\_beg\_pos[vert\_count]>0);}
\DoxyCodeLine{00046 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00047   \}}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049  \textcolor{keyword}{public}:}
\DoxyCodeLine{00050   VertexIndex\_t startIndexLen;  \textcolor{comment}{// this is actually the number of vertices (V)}}
\DoxyCodeLine{00051                                 \textcolor{comment}{// the actual length = +1}}
\DoxyCodeLine{00052   EdgeIndex\_t adjLen;           \textcolor{comment}{// the number of edges in the graph}}
\DoxyCodeLine{00053   EdgeIndex\_t weightLen;  \textcolor{comment}{// this should be the same as the number of edges}}
\DoxyCodeLine{00054   EdgeIndex\_t* startIndex;}
\DoxyCodeLine{00055   VertexIndex\_t* adjacency;}
\DoxyCodeLine{00056   Weight\_t* weight;}
\DoxyCodeLine{00057   \mbox{\hyperlink{classCSRGraph}{CSRGraph}}()}
\DoxyCodeLine{00058       : \mbox{\hyperlink{classGraph}{Graph}}(),}
\DoxyCodeLine{00059         startIndexLen(0),}
\DoxyCodeLine{00060         adjLen(0),}
\DoxyCodeLine{00061         weightLen(0),}
\DoxyCodeLine{00062         startIndex(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{00063         adjacency(\textcolor{keyword}{nullptr}),}
\DoxyCodeLine{00064         weight(\textcolor{keyword}{nullptr}) \{\}}
\DoxyCodeLine{00065   \string~\mbox{\hyperlink{classCSRGraph}{CSRGraph}}() \{}
\DoxyCodeLine{00066     \textcolor{comment}{// TODO: add matching deallocate, is this free or something else?}}
\DoxyCodeLine{00067   \}}
\DoxyCodeLine{00068   \mbox{\hyperlink{classCSRGraph}{CSRGraph}}(\textcolor{keyword}{const} \mbox{\hyperlink{classCSRGraph}{CSRGraph}}\& orig) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00069   \mbox{\hyperlink{classCSRGraph}{CSRGraph}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classCSRGraph}{CSRGraph}}\& orig) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00070 }
\DoxyCodeLine{00071   uint32\_t getV()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} startIndexLen; \}}
\DoxyCodeLine{00072   uint64\_t getE()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} adjLen; \}}
\DoxyCodeLine{00073 }
\DoxyCodeLine{00074   Weight\_t getW(VertexIndex\_t src, VertexIndex\_t dest)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{00075     \textcolor{keywordflow}{return} 0;  \textcolor{comment}{// TODO: make this work}}
\DoxyCodeLine{00076   \}}
\DoxyCodeLine{00077   \textcolor{keywordtype}{bool} isAdjacent(VertexIndex\_t src, VertexIndex\_t dest)\textcolor{keyword}{ const }\{}
\DoxyCodeLine{00078     \textcolor{keywordflow}{for} (EdgeIndex\_t i = startIndex[src]; i < startIndex[src + 1]; i++)}
\DoxyCodeLine{00079       \textcolor{keywordflow}{if} (adjacency[i] == dest) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{00080     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{00081   \}}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083   \textcolor{keywordtype}{void} getEdge(EdgeIndex\_t i, VertexIndex\_t* v1, VertexIndex\_t* v2) \{\}}
\DoxyCodeLine{00084   VertexIndex\_t countAdjacencies(VertexIndex\_t v) \{}
\DoxyCodeLine{00085     \textcolor{keywordflow}{return} startIndex[v + 1] -\/ startIndex[v];}
\DoxyCodeLine{00086   \}}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088   \mbox{\hyperlink{classCSRGraph}{CSRGraph}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} csrBeginName[], \textcolor{keyword}{const} \textcolor{keywordtype}{char} csrAdjName[],}
\DoxyCodeLine{00089            \textcolor{keyword}{const} \textcolor{keywordtype}{char} weightName[]) \{}
\DoxyCodeLine{00090     \textcolor{keywordtype}{double} tm = wtime();}
\DoxyCodeLine{00091     FILE* file = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00092     \textcolor{keywordtype}{size\_t} ret;}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     startIndexLen = fsize(csrBeginName) / \textcolor{keyword}{sizeof}(EdgeIndex\_t) -\/}
\DoxyCodeLine{00095                     1;  \textcolor{comment}{// one extra index for last one}}
\DoxyCodeLine{00096     adjLen = fsize(csrAdjName) / \textcolor{keyword}{sizeof}(VertexIndex\_t);}
\DoxyCodeLine{00097 }
\DoxyCodeLine{00098     \textcolor{comment}{// Read CSR starting Index}}
\DoxyCodeLine{00099     file = fopen(csrBeginName, \textcolor{stringliteral}{"{}rb"{}});}
\DoxyCodeLine{00100     \textcolor{keywordflow}{if} (file == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{throw} \textcolor{stringliteral}{"{}fopen fail csrbegin"{}};}
\DoxyCodeLine{00101     \textcolor{comment}{//      throw Ex(\_\_FILE\_\_, \_\_LINE\_\_, "{}Can't open"{});}}
\DoxyCodeLine{00102     startIndex = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104     \textcolor{comment}{// if(posix\_memalign((void **)\&startIndex, getpagesize(),}}
\DoxyCodeLine{00105     \textcolor{comment}{// sizeof(EdgeIndex\_t)*(startIndexLen+1)))}}
\DoxyCodeLine{00106     startIndex = \textcolor{keyword}{new} EdgeIndex\_t[startIndexLen + 1];}
\DoxyCodeLine{00107     \textcolor{comment}{// throw "{}posix memalign"{};}}
\DoxyCodeLine{00108     \textcolor{comment}{//      throw Ex2(\_\_FILE\_\_, \_\_LINE\_\_, "{}posix\_memalign"{});}}
\DoxyCodeLine{00109 }
\DoxyCodeLine{00110     ret = fread(startIndex, \textcolor{keyword}{sizeof}(EdgeIndex\_t), startIndexLen + 1, file);}
\DoxyCodeLine{00111     assert(ret == startIndexLen + 1);}
\DoxyCodeLine{00112     fclose(file);}
\DoxyCodeLine{00113 }
\DoxyCodeLine{00114     assert(adjLen == startIndex[startIndexLen]);}
\DoxyCodeLine{00115     std::cout << \textcolor{stringliteral}{"{}Expected edge count: "{}} << adjLen << \textcolor{stringliteral}{"{}\(\backslash\)n"{}};}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117     \textcolor{comment}{// Read adjacency list}}
\DoxyCodeLine{00118     file = fopen(csrAdjName, \textcolor{stringliteral}{"{}rb"{}});}
\DoxyCodeLine{00119     \textcolor{keywordflow}{if} (file == \textcolor{keyword}{nullptr}) \textcolor{keywordflow}{throw} \textcolor{stringliteral}{"{}fopen fail adj"{}};}
\DoxyCodeLine{00120     \textcolor{comment}{//      throw Ex(\_\_FILE\_\_, \_\_LINE\_\_, "{}Can't open"{});}}
\DoxyCodeLine{00121     adjacency = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123     \textcolor{comment}{// if(posix\_memalign((void **)\&adjacency, getpagesize(),}}
\DoxyCodeLine{00124     \textcolor{comment}{// sizeof(VertexIndex\_t)*(adjLen)))}}
\DoxyCodeLine{00125     adjacency = \textcolor{keyword}{new} VertexIndex\_t[adjLen];}
\DoxyCodeLine{00126     \textcolor{comment}{// throw "{}fopen fail memalign"{};}}
\DoxyCodeLine{00127     \textcolor{comment}{//      throw Ex(\_\_FILE\_\_, \_\_LINE\_\_, "{}posix\_memalign"{});}}
\DoxyCodeLine{00128 }
\DoxyCodeLine{00129     ret = fread(adjacency, \textcolor{keyword}{sizeof}(VertexIndex\_t), adjLen, file);}
\DoxyCodeLine{00130     assert(ret == adjLen);}
\DoxyCodeLine{00131     fclose(file);}
\DoxyCodeLine{00132     V = startIndexLen;}
\DoxyCodeLine{00133     E = adjLen;}
\DoxyCodeLine{00134 }
\DoxyCodeLine{00135     std::cout << \textcolor{stringliteral}{"{}Graph load (success): "{}} << startIndexLen << \textcolor{stringliteral}{"{} verts, "{}}}
\DoxyCodeLine{00136               << adjLen << \textcolor{stringliteral}{"{} edges "{}} << wtime() -\/ tm << \textcolor{stringliteral}{"{} second(s)\(\backslash\)n"{}};}
\DoxyCodeLine{00137   \}}
\DoxyCodeLine{00138 }
\DoxyCodeLine{00139   \textcolor{keyword}{typedef} void (*FuncVert)(uint32\_t src, uint32\_t dest);}
\DoxyCodeLine{00140   \textcolor{comment}{/*}}
\DoxyCodeLine{00141 \textcolor{comment}{}}
\DoxyCodeLine{00142 \textcolor{comment}{   */}}
\DoxyCodeLine{00143   \textcolor{keywordtype}{void} dfs(VertexIndex\_t v, FuncVert f) \{}
\DoxyCodeLine{00144     \textcolor{keywordtype}{bool} visited[getV()] = \{\textcolor{keyword}{false}\};}
\DoxyCodeLine{00145     \mbox{\hyperlink{classStack}{Stack<VertexIndex\_t>}} toVisit(getV());}
\DoxyCodeLine{00146     toVisit.push(v);}
\DoxyCodeLine{00147     visited[v] = \textcolor{keyword}{true};}
\DoxyCodeLine{00148     f(v, v);}
\DoxyCodeLine{00149     \textcolor{keywordflow}{while} (!toVisit.isEmpty()) \{}
\DoxyCodeLine{00150       VertexIndex\_t src = toVisit.pop();}
\DoxyCodeLine{00151       \textcolor{keywordflow}{for} (EdgeIndex\_t i = startIndex[src]; i < startIndex[src + 1]; i++) \{}
\DoxyCodeLine{00152         VertexIndex\_t dest = adjacency[i];}
\DoxyCodeLine{00153         \textcolor{keywordflow}{if} (!visited[dest]) \{}
\DoxyCodeLine{00154           toVisit.push(dest);}
\DoxyCodeLine{00155           visited[dest] = \textcolor{keyword}{true};}
\DoxyCodeLine{00156           \textcolor{comment}{// update the graph}}
\DoxyCodeLine{00157           f(src, dest);}
\DoxyCodeLine{00158         \}}
\DoxyCodeLine{00159       \}}
\DoxyCodeLine{00160     \}}
\DoxyCodeLine{00161   \}}
\DoxyCodeLine{00162 }
\DoxyCodeLine{00163   \textcolor{comment}{/*}}
\DoxyCodeLine{00164 \textcolor{comment}{}}
\DoxyCodeLine{00165 \textcolor{comment}{   */}}
\DoxyCodeLine{00166   \textcolor{keywordtype}{void} bfs(uint32\_t v, FuncVert f) \{}
\DoxyCodeLine{00167     \textcolor{keywordtype}{bool} visited[getV()] = \{\textcolor{keyword}{false}\};}
\DoxyCodeLine{00168     std::queue<VertexIndex\_t> toVisit;}
\DoxyCodeLine{00169     toVisit.enqueue(v);}
\DoxyCodeLine{00170     visited[v] = \textcolor{keyword}{true};}
\DoxyCodeLine{00171     f(v, v);}
\DoxyCodeLine{00172     \textcolor{keywordflow}{while} (!toVisit.empty()) \{}
\DoxyCodeLine{00173       VertexIndex\_t src = toVisit.dequeue();}
\DoxyCodeLine{00174       \textcolor{keywordflow}{for} (EdgeIndex\_t i = startIndex[src]; i < startIndex[src + 1]; i++) \{}
\DoxyCodeLine{00175         VertexIndex\_t dest = adjacency[i];}
\DoxyCodeLine{00176         \textcolor{keywordflow}{if} (!visited[dest]) \{}
\DoxyCodeLine{00177           toVisit.enqueue(dest);}
\DoxyCodeLine{00178           visited[dest] = \textcolor{keyword}{true};}
\DoxyCodeLine{00179           \textcolor{comment}{// update the graph}}
\DoxyCodeLine{00180           f(src, dest);}
\DoxyCodeLine{00181         \}}
\DoxyCodeLine{00182       \}}
\DoxyCodeLine{00183     \}}
\DoxyCodeLine{00184   \}}
\DoxyCodeLine{00185   uint32\_t* computeHistogram()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{00186     uint32\_t* hist = \textcolor{keyword}{new} uint32\_t[getV()] = \{0\};}
\DoxyCodeLine{00187     \textcolor{keywordflow}{for} (VertexIndex\_t v = 0; v < getV(); v++) hist[countAdjacencies(v)]++;}
\DoxyCodeLine{00188     \textcolor{keywordflow}{return} hist;}
\DoxyCodeLine{00189   \}}
\DoxyCodeLine{00190 }
\DoxyCodeLine{00191   \textcolor{keywordtype}{void} printHistogram()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{00192     uint32\_t hist = computeHistogram();}
\DoxyCodeLine{00193     \textcolor{keywordflow}{for} (VertexIndex\_t i = 0; i < getV(); i++)}
\DoxyCodeLine{00194       \textcolor{keywordflow}{if} (hist[i] != 0) \{}
\DoxyCodeLine{00195         std::cout << i << \textcolor{stringliteral}{"{}: "{}} << hist[i] << \textcolor{charliteral}{'\(\backslash\)n'};}
\DoxyCodeLine{00196       \}}
\DoxyCodeLine{00197     \textcolor{keyword}{delete}[] hist;}
\DoxyCodeLine{00198   \}}
\DoxyCodeLine{00199 }
\DoxyCodeLine{\Hypertarget{CSRGraph_8hh_source_l00200}\mbox{\hyperlink{structCSRGraph_1_1VertexCount}{00200}}   \textcolor{keyword}{struct }\mbox{\hyperlink{structCSRGraph_1_1VertexCount}{VertexCount}} \{}
\DoxyCodeLine{00201     VertexIndex\_t v;}
\DoxyCodeLine{00202     VertexIndex\_t countAdj;}
\DoxyCodeLine{00203     \mbox{\hyperlink{structCSRGraph_1_1VertexCount}{VertexCount}}() : v(0), countAdj(0) \{\}}
\DoxyCodeLine{00204     \mbox{\hyperlink{structCSRGraph_1_1VertexCount}{VertexCount}}(VertexIndex\_t v, VertexIndex\_t countAdj)}
\DoxyCodeLine{00205         : v(v), countAdj(countAdj) \{\}}
\DoxyCodeLine{00206   \};}
\DoxyCodeLine{00207   \textcolor{keyword}{static} \textcolor{keywordtype}{bool} sortDescCount(\textcolor{keyword}{const} \mbox{\hyperlink{structCSRGraph_1_1VertexCount}{VertexCount}}\& a, \textcolor{keyword}{const} \mbox{\hyperlink{structCSRGraph_1_1VertexCount}{VertexCount}}\& b) \{}
\DoxyCodeLine{00208     \textcolor{keywordflow}{return} a.countAdj > b.countAdj;}
\DoxyCodeLine{00209   \}}
\DoxyCodeLine{00210   \textcolor{keyword}{const} VertexIndex\_t* group() \{}
\DoxyCodeLine{00211     VertexIndex\_t V = getV();}
\DoxyCodeLine{00212     VertexCount* v = \textcolor{keyword}{new} VertexCount[V];}
\DoxyCodeLine{00213 }
\DoxyCodeLine{00214     \textcolor{keywordflow}{for} (VertexIndex\_t i = 0; i < V; i++)}
\DoxyCodeLine{00215       v[i] = VertexCount(i, countAdjacencies(i));}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217     std::sort(v, v + V, sortDescCount);}
\DoxyCodeLine{00218     VertexIndex\_t* vertices = \textcolor{keyword}{new} VertexIndex\_t[V];}
\DoxyCodeLine{00219     \textcolor{keywordflow}{for} (VertexIndex\_t i = 0; i < V; i++) vertices[i] = v[i].v;}
\DoxyCodeLine{00220     \textcolor{keyword}{delete}[] v;}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222     \textcolor{keywordflow}{return} vertices;}
\DoxyCodeLine{00223   \}}
\DoxyCodeLine{00224 }
\DoxyCodeLine{00225   \textcolor{keywordtype}{void} cluster() \{}
\DoxyCodeLine{00226     constexpr \textcolor{keywordtype}{int} n = 4;}
\DoxyCodeLine{00227     uint32\_t V = getV();}
\DoxyCodeLine{00228     uint32\_t avg = V / (n * n);}
\DoxyCodeLine{00229     std::vector<VertexIndex\_t> grid[n][n];}
\DoxyCodeLine{00230     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < n; i++)}
\DoxyCodeLine{00231       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < n; j++) grid[i][j].reserve(avg);}
\DoxyCodeLine{00232     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < V; i++) \{}
\DoxyCodeLine{00233     \}}
\DoxyCodeLine{00234   \}}
\DoxyCodeLine{00235 \};}

\end{DoxyCode}
