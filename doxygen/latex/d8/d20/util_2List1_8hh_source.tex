\hypertarget{util_2List1_8hh_source}{}\doxysection{List1.\+hh}
\label{util_2List1_8hh_source}\index{src/util/List1.hh@{src/util/List1.hh}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{00002 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{00003 }
\DoxyCodeLine{00004 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00005 \textcolor{keyword}{class }\mbox{\hyperlink{classList1}{List1}} \{}
\DoxyCodeLine{00006  \textcolor{keyword}{private}:}
\DoxyCodeLine{00007   std::vector<T> data;}
\DoxyCodeLine{00008 }
\DoxyCodeLine{00009  \textcolor{keyword}{public}:}
\DoxyCodeLine{00010   \mbox{\hyperlink{classList1}{List1}}()\{\};}
\DoxyCodeLine{00011   \mbox{\hyperlink{classList1}{List1}}(uint32\_t initialSize) \{ data.reserve(initialSize); \}}
\DoxyCodeLine{00012   \textcolor{comment}{// TODO: do I even need a copy constructor?}}
\DoxyCodeLine{00013   \mbox{\hyperlink{classList1}{List1}}(\textcolor{keyword}{const} \mbox{\hyperlink{classList1}{List1}}\& orig) \{}
\DoxyCodeLine{00014     uint32\_t used = orig.getUsed();}
\DoxyCodeLine{00015     data.reserve(used);}
\DoxyCodeLine{00016     \textcolor{comment}{// TODO: replace this with copy if needed}}
\DoxyCodeLine{00017     data.assign(orig.data.begin(), orig.data.end());}
\DoxyCodeLine{00018   \}}
\DoxyCodeLine{00019   uint32\_t serializeSize()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{00020     \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(uint32\_t) + data.size() * \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00021   \}}
\DoxyCodeLine{00022   \textcolor{keywordtype}{char}* read(\textcolor{keywordtype}{char}* p) \{}
\DoxyCodeLine{00023     uint32\_t used = *(uint32\_t*)p;}
\DoxyCodeLine{00024     p += \textcolor{keyword}{sizeof}(uint32\_t);}
\DoxyCodeLine{00025     \textcolor{comment}{// data = (T*)new char[used*sizeof(T)];}}
\DoxyCodeLine{00026     data.reserve(used);}
\DoxyCodeLine{00027     memcpy(p, data, used * \textcolor{keyword}{sizeof}(T));}
\DoxyCodeLine{00028     \textcolor{keywordflow}{return} p + used * \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00029   \}}
\DoxyCodeLine{00030   \textcolor{keywordtype}{char}* write(\textcolor{keywordtype}{char}* p) \{}
\DoxyCodeLine{00031     uint32\_t used = data.size();}
\DoxyCodeLine{00032     *(uint32\_t*)p = used;}
\DoxyCodeLine{00033     p += \textcolor{keyword}{sizeof}(uint32\_t);}
\DoxyCodeLine{00034     memcpy(p, \&data[0], used * \textcolor{keyword}{sizeof}(T));}
\DoxyCodeLine{00035     \textcolor{keywordflow}{return} p + used * \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00036   \}}
\DoxyCodeLine{00037   \textcolor{keywordtype}{void} add(\textcolor{keyword}{const} T\& v) \{ data.push\_back(v); \}}
\DoxyCodeLine{00038   uint32\_t getUsed()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data.size(); \}}
\DoxyCodeLine{00039   uint32\_t getCapacity()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data.size(); \}}
\DoxyCodeLine{00040   T getData(\textcolor{keywordtype}{int} i)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data[i]; \}}
\DoxyCodeLine{00041   uint32\_t size()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} data.size() * \textcolor{keyword}{sizeof}(T); \}}
\DoxyCodeLine{00042 \};}

\end{DoxyCode}
