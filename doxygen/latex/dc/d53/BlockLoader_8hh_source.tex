\hypertarget{BlockLoader_8hh_source}{}\doxysection{Block\+Loader.\+hh}
\label{BlockLoader_8hh_source}\index{src/data/BlockLoader.hh@{src/data/BlockLoader.hh}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{00002 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{00003 }
\DoxyCodeLine{00004 \textcolor{comment}{/*}}
\DoxyCodeLine{00005 \textcolor{comment}{  A BlockLoader is a class of file format designed to be loaded in a}}
\DoxyCodeLine{00006 \textcolor{comment}{  single read Ultra-\/efficient load times, low CPU utilization with a}}
\DoxyCodeLine{00007 \textcolor{comment}{  header that supports a common architecture for digital signature and}}
\DoxyCodeLine{00008 \textcolor{comment}{  authentication across all BlockLoader Types.}}
\DoxyCodeLine{00009 \textcolor{comment}{*/}}
\DoxyCodeLine{\Hypertarget{BlockLoader_8hh_source_l00010}\mbox{\hyperlink{classBlockLoader}{00010}} \textcolor{keyword}{class }\mbox{\hyperlink{classBlockLoader}{BlockLoader}} \{}
\DoxyCodeLine{00011  \textcolor{keyword}{public}:}
\DoxyCodeLine{00012   \textcolor{comment}{// std::unique\_ptr<uint64\_t> mem;}}
\DoxyCodeLine{00013   uint64\_t* mem;  \textcolor{comment}{// hating unique pointers right now}}
\DoxyCodeLine{00014   uint64\_t size;}
\DoxyCodeLine{\Hypertarget{BlockLoader_8hh_source_l00015}\mbox{\hyperlink{structBlockLoader_1_1GeneralHeader}{00015}}   \textcolor{keyword}{struct }\mbox{\hyperlink{structBlockLoader_1_1GeneralHeader}{GeneralHeader}} \{}
\DoxyCodeLine{00016     uint32\_t magic;         \textcolor{comment}{// magic number for all block loaders}}
\DoxyCodeLine{00017     uint32\_t type : 16;     \textcolor{comment}{// type of block loader}}
\DoxyCodeLine{00018     uint32\_t version : 16;  \textcolor{comment}{// version}}
\DoxyCodeLine{00019   \};}
\DoxyCodeLine{\Hypertarget{BlockLoader_8hh_source_l00020}\mbox{\hyperlink{structBlockLoader_1_1SecurityHeaderV0}{00020}}   \textcolor{keyword}{struct }\mbox{\hyperlink{structBlockLoader_1_1SecurityHeaderV0}{SecurityHeaderV0}} \{}
\DoxyCodeLine{00021     uint64\_t yoho;  \textcolor{comment}{// TODO: put something in}}
\DoxyCodeLine{00022   \};}
\DoxyCodeLine{00023 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{00024     \textcolor{keyword}{struct }\mbox{\hyperlink{structBlockLoader_1_1SecurityHeaderV1}{SecurityHeaderV1}} \{}
\DoxyCodeLine{00025         uint8\_t hash[32];  \textcolor{comment}{// SHA256 hash signed by author}}
\DoxyCodeLine{00026         uint8\_t hash2[32]; \textcolor{comment}{// SHA256 hash of alternate region in data signed by author}}
\DoxyCodeLine{00027         uint8\_t \textcolor{keywordtype}{id}[32]; \textcolor{comment}{// id of author}}
\DoxyCodeLine{00028     \};}
\DoxyCodeLine{00029 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031   GeneralHeader* generalHeader;}
\DoxyCodeLine{00032   SecurityHeaderV0* securityHeader;}
\DoxyCodeLine{00033   \textcolor{keyword}{enum class} Type \{ gismap, hashmap \};}
\DoxyCodeLine{00034 }
\DoxyCodeLine{00035  \textcolor{keyword}{protected}:}
\DoxyCodeLine{00036   \textcolor{comment}{/*}}
\DoxyCodeLine{00037 \textcolor{comment}{    TODO: Find better way than uninitialized parent?}}
\DoxyCodeLine{00038 \textcolor{comment}{    problem: We need to allocate memory in base class to share}}
\DoxyCodeLine{00039 \textcolor{comment}{    memory allocation and common headers among all BlockLoaders.}}
\DoxyCodeLine{00040 \textcolor{comment}{    But we don't know how much memory we need until we open the file}}
\DoxyCodeLine{00041 \textcolor{comment}{    read all the information from ESRI and create.}}
\DoxyCodeLine{00042 \textcolor{comment}{    In any file format, there will be this problem. There must be a}}
\DoxyCodeLine{00043 \textcolor{comment}{    temporary object structure while you read in and figure out how big}}
\DoxyCodeLine{00044 \textcolor{comment}{    the data is. Then, once the data is known, you can read in a single}}
\DoxyCodeLine{00045 \textcolor{comment}{    contiguous block of memory, fill it and save that out to disk for}}
\DoxyCodeLine{00046 \textcolor{comment}{    rapid loading later.}}
\DoxyCodeLine{00047 \textcolor{comment}{}}
\DoxyCodeLine{00048 \textcolor{comment}{    One way to eliminate this problem might be to allocate the header and}}
\DoxyCodeLine{00049 \textcolor{comment}{    what for us is the segment information for the map with lots of}}
\DoxyCodeLine{00050 \textcolor{comment}{    extra space at the end. We make the list as big as it needs to be and}}
\DoxyCodeLine{00051 \textcolor{comment}{    just keep an extra data structure with the points. Then, when done}}
\DoxyCodeLine{00052 \textcolor{comment}{    growing define a pointer to the points at the end and copy in.}}
\DoxyCodeLine{00053 \textcolor{comment}{}}
\DoxyCodeLine{00054 \textcolor{comment}{    The uninitialized protected constructor is only for use by children}}
\DoxyCodeLine{00055 \textcolor{comment}{    who first figure out how big, then call init() to initialize their}}
\DoxyCodeLine{00056 \textcolor{comment}{    parent. The only alternative would be to call the parent constructor}}
\DoxyCodeLine{00057 \textcolor{comment}{    passing in the information (type and version is easy, number of bytes}}
\DoxyCodeLine{00058 \textcolor{comment}{    requires knowing everything before call) This would require returning}}
\DoxyCodeLine{00059 \textcolor{comment}{    a structure with those 3 items. Should probably just do that.}}
\DoxyCodeLine{00060 \textcolor{comment}{  */}}
\DoxyCodeLine{00061   \mbox{\hyperlink{classBlockLoader}{BlockLoader}}() \{\}}
\DoxyCodeLine{\Hypertarget{BlockLoader_8hh_source_l00062}\mbox{\hyperlink{structBlockLoader_1_1Info}{00062}}   \textcolor{keyword}{struct }\mbox{\hyperlink{structBlockLoader_1_1Info}{Info}} \{}
\DoxyCodeLine{00063     uint64\_t bytes;}
\DoxyCodeLine{00064     Type t;}
\DoxyCodeLine{00065     uint32\_t version;}
\DoxyCodeLine{00066   \};}
\DoxyCodeLine{00067   \mbox{\hyperlink{classBlockLoader}{BlockLoader}}(\textcolor{keyword}{const} \mbox{\hyperlink{structBlockLoader_1_1Info}{Info}}\& info);}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069  \textcolor{keyword}{public}:}
\DoxyCodeLine{00070   \mbox{\hyperlink{classBlockLoader}{BlockLoader}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} filename[]);}
\DoxyCodeLine{00071   \string~\mbox{\hyperlink{classBlockLoader}{BlockLoader}}() \{ \textcolor{keyword}{delete}[] mem; \}}
\DoxyCodeLine{00072   \mbox{\hyperlink{classBlockLoader}{BlockLoader}}(\textcolor{keyword}{const} \mbox{\hyperlink{classBlockLoader}{BlockLoader}}\& orig) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00073   \mbox{\hyperlink{classBlockLoader}{BlockLoader}}\& operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classBlockLoader}{BlockLoader}}\& orig) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00074 }
\DoxyCodeLine{00075   \textcolor{keywordtype}{void} init(uint64\_t* mem, uint64\_t size);}
\DoxyCodeLine{00076   \textcolor{keywordtype}{void} init(uint64\_t bytes, Type t, uint32\_t version);}
\DoxyCodeLine{00077   \textcolor{comment}{// Fast load a blockfile}}
\DoxyCodeLine{00078   \textcolor{keywordtype}{void} readBlockFile(\textcolor{keyword}{const} \textcolor{keywordtype}{char} filename[]);}
\DoxyCodeLine{00079   \textcolor{comment}{// get the size of the SecurityHeader for any BlockLoader}}
\DoxyCodeLine{00080   uint32\_t getAuthHeaderSize()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(SecurityHeaderV0); \}}
\DoxyCodeLine{00081   uint32\_t getHeaderSize()\textcolor{keyword}{ const }\{}
\DoxyCodeLine{00082     \textcolor{keywordflow}{return} \textcolor{keyword}{sizeof}(GeneralHeader) + \textcolor{keyword}{sizeof}(SecurityHeaderV0);}
\DoxyCodeLine{00083   \}}
\DoxyCodeLine{00084   \textcolor{keywordtype}{bool} authenticate() \textcolor{keyword}{const};}
\DoxyCodeLine{00085   \mbox{\hyperlink{classBlockLoader}{BlockLoader}}(uint64\_t bytes, Type t, uint32\_t version)}
\DoxyCodeLine{00086       : mem(new uint64\_t[(getHeaderSize() + (bytes + 7) / 8)]) \{}
\DoxyCodeLine{00087     \textcolor{comment}{// std::make\_unique<uint64\_t[]>(getHeaderSize() + (bytes + 7) / 8)) \{}}
\DoxyCodeLine{00088     generalHeader = (GeneralHeader*)mem;  \textcolor{comment}{// header is the first chunk of bytes}}
\DoxyCodeLine{00089     generalHeader-\/>magic = (((((\textcolor{charliteral}{'!'} << 8) + \textcolor{charliteral}{'B'}) << 8) + \textcolor{charliteral}{'L'}) << 8) +}
\DoxyCodeLine{00090                            \textcolor{charliteral}{'d'};  \textcolor{comment}{// magic number for all block loaders}}
\DoxyCodeLine{00091     generalHeader-\/>type = uint32\_t(t);}
\DoxyCodeLine{00092     generalHeader-\/>version = version;}
\DoxyCodeLine{00093     securityHeader =}
\DoxyCodeLine{00094         (SecurityHeaderV0*)((uint64\_t*)mem + \textcolor{keyword}{sizeof}(GeneralHeader) / 8);}
\DoxyCodeLine{00095   \}}
\DoxyCodeLine{00096 \};}

\end{DoxyCode}
