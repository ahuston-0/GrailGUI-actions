\hypertarget{Buffer_8hh_source}{}\doxysection{Buffer.\+hh}
\label{Buffer_8hh_source}\index{src/util/Buffer.hh@{src/util/Buffer.hh}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{00002 }
\DoxyCodeLine{00003 \textcolor{preprocessor}{\#include <fcntl.h>}}
\DoxyCodeLine{00004 \textcolor{preprocessor}{\#include <unistd.h>}}
\DoxyCodeLine{00005 }
\DoxyCodeLine{00006 \textcolor{preprocessor}{\#include <cstddef>}}
\DoxyCodeLine{00007 \textcolor{preprocessor}{\#include <cstdint>}}
\DoxyCodeLine{00008 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{00009 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{00010 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{00011 \textcolor{preprocessor}{\#include <regex>}}
\DoxyCodeLine{00012 \textcolor{preprocessor}{\#include <string>}}
\DoxyCodeLine{00013 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{00014 }
\DoxyCodeLine{00015 \textcolor{preprocessor}{\#include "{}csp/SocketIO.hh"{}}}
\DoxyCodeLine{00016 \textcolor{preprocessor}{\#include "{}csp/csp.hh"{}}}
\DoxyCodeLine{00017 \textcolor{preprocessor}{\#include "{}csp/cspservlet/Student.hh"{}}}
\DoxyCodeLine{00018 \textcolor{preprocessor}{\#include "{}util/List1.hh"{}}}
\DoxyCodeLine{00019 \textcolor{preprocessor}{\#include "{}util/datatype.hh"{}}}
\DoxyCodeLine{00020 }
\DoxyCodeLine{00021 \textcolor{keyword}{class }\mbox{\hyperlink{classXDLRaw}{XDLRaw}};}
\DoxyCodeLine{00022 }
\DoxyCodeLine{00023 \textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{00024 \textcolor{keyword}{class }\mbox{\hyperlink{classBuffer}{Buffer}} \{}
\DoxyCodeLine{00025  \textcolor{keyword}{public}:}
\DoxyCodeLine{00026   \mbox{\hyperlink{classBuffer}{Buffer}}(\textcolor{keywordtype}{size\_t} initialSize, \textcolor{keywordtype}{bool} writing);}
\DoxyCodeLine{00027   \mbox{\hyperlink{classBuffer}{Buffer}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} filename[], \textcolor{keywordtype}{size\_t} initialSize);}
\DoxyCodeLine{00028   \mbox{\hyperlink{classBuffer}{Buffer}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char} filename[], \textcolor{keywordtype}{size\_t} initialSize, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*);}
\DoxyCodeLine{00029   \mbox{\hyperlink{classBuffer}{Buffer}}(\textcolor{keyword}{const} \mbox{\hyperlink{classBuffer}{Buffer}}\& c) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00030   \string~\mbox{\hyperlink{classBuffer}{Buffer}}() \{}
\DoxyCodeLine{00031     \textcolor{keywordflow}{if} (writing) flush();}
\DoxyCodeLine{00032     \textcolor{keyword}{delete}[] preBuffer;}
\DoxyCodeLine{00033   \}}
\DoxyCodeLine{00034   \textcolor{keywordtype}{void} operator=(\textcolor{keyword}{const} \mbox{\hyperlink{classBuffer}{Buffer}}\& orig) = \textcolor{keyword}{delete};}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036   \textcolor{keywordtype}{void} attachWrite(\textcolor{keywordtype}{int} sockfd) \{}
\DoxyCodeLine{00037     fd = sockfd;}
\DoxyCodeLine{00038     p = buffer;}
\DoxyCodeLine{00039     availSize = size;}
\DoxyCodeLine{00040   \}}
\DoxyCodeLine{00041 }
\DoxyCodeLine{00042   \textcolor{keywordtype}{void} attachRead(\textcolor{keywordtype}{int} sockfd) \{}
\DoxyCodeLine{00043     fd = sockfd;}
\DoxyCodeLine{00044     p = buffer;}
\DoxyCodeLine{00045     availSize = size;}
\DoxyCodeLine{00046     readNext();}
\DoxyCodeLine{00047   \}}
\DoxyCodeLine{00048 }
\DoxyCodeLine{00049   \textcolor{keywordtype}{void} displayText(ostream\& s) \textcolor{keyword}{const};}
\DoxyCodeLine{00050   \textcolor{keywordtype}{void} displayRawRead() \textcolor{keyword}{const};}
\DoxyCodeLine{00051   \textcolor{keywordtype}{void} displayRaw() \textcolor{keyword}{const};}
\DoxyCodeLine{00052   \textcolor{keywordtype}{void} displayHTTPRaw();  \textcolor{comment}{// TODO: eliminate! die die die}}
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054   \textcolor{keywordtype}{void} flush() \{  \textcolor{comment}{// TODO: this will fail if we overflow slightly}}
\DoxyCodeLine{00055     \textcolor{keywordflow}{if} (isSockBuf)}
\DoxyCodeLine{00056       SocketIO::send(fd, buffer, p -\/ buffer, 0);}
\DoxyCodeLine{00057     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{00058       \textcolor{keywordflow}{if} (::write(fd, buffer, p -\/ buffer) < 0) \textcolor{keywordflow}{throw} Ex1(Errcode::FILE\_WRITE);}
\DoxyCodeLine{00059     \}}
\DoxyCodeLine{00060     p = buffer;}
\DoxyCodeLine{00061     availSize = size;}
\DoxyCodeLine{00062   \}}
\DoxyCodeLine{00063   \textcolor{keywordtype}{void} readNext();}
\DoxyCodeLine{00064   \textcolor{comment}{// write is binary}}
\DoxyCodeLine{00065   \textcolor{keywordtype}{void} write(\textcolor{keyword}{const} \textcolor{keywordtype}{string}\& s);}
\DoxyCodeLine{00066   \textcolor{keywordtype}{void} write(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* s, uint32\_t len);}
\DoxyCodeLine{00067 }
\DoxyCodeLine{00068   \textcolor{comment}{// append is ASCII text}}
\DoxyCodeLine{00069   \textcolor{keywordtype}{void} appendU8(uint8\_t);}
\DoxyCodeLine{00070   \textcolor{keywordtype}{void} appendU16(uint16\_t);}
\DoxyCodeLine{00071   \textcolor{keywordtype}{void} appendU32(uint32\_t);}
\DoxyCodeLine{00072   \textcolor{keywordtype}{void} appendU64(uint64\_t);}
\DoxyCodeLine{00073   \textcolor{keywordtype}{void} appendI8(int8\_t);}
\DoxyCodeLine{00074   \textcolor{keywordtype}{void} appendI16(int16\_t);}
\DoxyCodeLine{00075   \textcolor{keywordtype}{void} appendI32(int32\_t);}
\DoxyCodeLine{00076   \textcolor{keywordtype}{void} appendI64(int64\_t);}
\DoxyCodeLine{00077   \textcolor{keywordtype}{void} appendF32(\textcolor{keywordtype}{float});}
\DoxyCodeLine{00078   \textcolor{keywordtype}{void} appendF64(\textcolor{keywordtype}{double});}
\DoxyCodeLine{00079   \textcolor{keywordtype}{void} append(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* v);}
\DoxyCodeLine{00080   \textcolor{keywordtype}{void} append(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* v, uint32\_t len);}
\DoxyCodeLine{00081 }
\DoxyCodeLine{00082   \textcolor{comment}{//    void append(float f);}}
\DoxyCodeLine{00083   uint32\_t parseU32() \{}
\DoxyCodeLine{00084     \textcolor{keywordtype}{char}* temp;}
\DoxyCodeLine{00085     uint32\_t v = strtoul(p, \&temp, 10);}
\DoxyCodeLine{00086     p = temp;}
\DoxyCodeLine{00087     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{00088   \}}
\DoxyCodeLine{00089   \textcolor{keywordtype}{double} parseF64() \{}
\DoxyCodeLine{00090     \textcolor{keywordtype}{char}* temp;}
\DoxyCodeLine{00091     \textcolor{keywordtype}{double} v = strtod(p, \&temp);}
\DoxyCodeLine{00092     p = temp;}
\DoxyCodeLine{00093     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{00094   \}}
\DoxyCodeLine{00095   \textcolor{keywordtype}{float} parseF32() \{}
\DoxyCodeLine{00096     \textcolor{keywordtype}{char}* temp;}
\DoxyCodeLine{00097     \textcolor{keywordtype}{float} v = strtof(p, \&temp);}
\DoxyCodeLine{00098     p = temp;}
\DoxyCodeLine{00099     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{00100   \}}
\DoxyCodeLine{00101 }
\DoxyCodeLine{00102   \textcolor{keywordtype}{bool} parseRegex(\textcolor{keyword}{const} regex\& r, \textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& start, \textcolor{keywordtype}{int}\& len);}
\DoxyCodeLine{00103   \textcolor{comment}{// if parse returns true, advance past the token}}
\DoxyCodeLine{00104   \textcolor{keywordtype}{bool} parseToken(\textcolor{keyword}{const} \textcolor{keywordtype}{string}\& match);}
\DoxyCodeLine{00105   \textcolor{keywordtype}{bool} getUrl(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& ptr, uint32\_t\& len);}
\DoxyCodeLine{00106   \textcolor{keywordtype}{bool} getHTTPVersion(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& ptr, uint32\_t\& len);}
\DoxyCodeLine{00107   \textcolor{keywordtype}{bool} getHost(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& ptr, uint32\_t\& len);}
\DoxyCodeLine{00108   \textcolor{keywordtype}{void} pointToStart();}
\DoxyCodeLine{00115   \textcolor{keywordtype}{bool} getNextTokenWithSpace(\textcolor{keyword}{const} \textcolor{keywordtype}{char}*\& ptr, \textcolor{keyword}{const} uint32\_t\& len);}
\DoxyCodeLine{00116   \textcolor{keywordtype}{string} readString8();}
\DoxyCodeLine{00117   \textcolor{keywordtype}{string} readString16();}
\DoxyCodeLine{00118   \textcolor{keywordtype}{string} readString32();}
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120   \textcolor{comment}{/*}}
\DoxyCodeLine{00121 \textcolor{comment}{    Write out a data type as a single byte}}
\DoxyCodeLine{00122 \textcolor{comment}{   */}}
\DoxyCodeLine{00123   \textcolor{keywordtype}{void} write(DataType t) \{ write(uint8\_t(t)); \}}
\DoxyCodeLine{00124   DataType readType() \{ \textcolor{keywordflow}{return} DataType(*p++); \}}
\DoxyCodeLine{00125 }
\DoxyCodeLine{00126   \textcolor{keywordtype}{void} write(DataType t, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* name) \{}
\DoxyCodeLine{00127     write(t);}
\DoxyCodeLine{00128     write(name, strlen(name));}
\DoxyCodeLine{00129   \}}
\DoxyCodeLine{00130 }
\DoxyCodeLine{00138   \textcolor{comment}{//************ uint8\_t uint16\_t uint32\_t uint64\_t *************//}}
\DoxyCodeLine{00139   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\Hypertarget{Buffer_8hh_source_l00140}\mbox{\hyperlink{classBuffer_a63aed180baa43f1304aad55015dcd238}{00140}}   \textcolor{keywordtype}{void} \mbox{\hyperlink{classBuffer_a63aed180baa43f1304aad55015dcd238}{write}}(T v) \{}
\DoxyCodeLine{00141     *(T*)p = v;}
\DoxyCodeLine{00142     p = p + \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00143     availSize -\/= \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00144   \}}
\DoxyCodeLine{00145 }
\DoxyCodeLine{00151   \textcolor{keywordtype}{void} write(\mbox{\hyperlink{classXDLRaw}{XDLRaw}}\& v);}
\DoxyCodeLine{00152 }
\DoxyCodeLine{00153   \textcolor{comment}{// for writing big objects, don't copy into the buffer, write it to the socket}}
\DoxyCodeLine{00154   \textcolor{comment}{// directly}}
\DoxyCodeLine{00155   \textcolor{keywordtype}{void} specialWrite(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* buf, \textcolor{keyword}{const} uint32\_t len) \{}
\DoxyCodeLine{00156     flush();}
\DoxyCodeLine{00157     ::write(fd, buf, len);}
\DoxyCodeLine{00158   \}}
\DoxyCodeLine{00159 }
\DoxyCodeLine{00160   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00161   \textcolor{keywordtype}{void} writeList(\mbox{\hyperlink{classList1}{List1<T>}}\& list) \{}
\DoxyCodeLine{00162     checkSpace(list.serializeSize());}
\DoxyCodeLine{00163     list.write(p);}
\DoxyCodeLine{00164     p += list.serializeSize();}
\DoxyCodeLine{00165     availSize -\/= list.serializeSize();}
\DoxyCodeLine{00166   \}}
\DoxyCodeLine{00167 }
\DoxyCodeLine{00168   \textcolor{keywordtype}{void} writeStudent(\mbox{\hyperlink{classStudent}{Student}} v) \{}
\DoxyCodeLine{00169     checkSpace(v.serializeSize());}
\DoxyCodeLine{00170     v.write(p);}
\DoxyCodeLine{00171     p += v.serializeSize();}
\DoxyCodeLine{00172     availSize -\/= v.serializeSize();}
\DoxyCodeLine{00173   \}}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175   \textcolor{comment}{// template<>}}
\DoxyCodeLine{00176   \textcolor{keywordtype}{void} writeList(\mbox{\hyperlink{classList1}{List1<Student>}}\& list) \{}
\DoxyCodeLine{00177     write(list.getUsed());}
\DoxyCodeLine{00178     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < list.getUsed(); i++) \{}
\DoxyCodeLine{00179       writeStudent(list.getData(i));}
\DoxyCodeLine{00180     \}}
\DoxyCodeLine{00181   \}}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183   \textcolor{comment}{//************ uint8\_t uint16\_t uint32\_t uint64\_t array *************//}}
\DoxyCodeLine{00184   \textcolor{comment}{/*}}
\DoxyCodeLine{00185 \textcolor{comment}{   if there is not enough space to write this data without overflowing the}}
\DoxyCodeLine{00186 \textcolor{comment}{   buffer overflow region, then flush.  This assumes that the object being}}
\DoxyCodeLine{00187 \textcolor{comment}{   written is small enough to fit into the buffer at all}}
\DoxyCodeLine{00188 \textcolor{comment}{   */}}
\DoxyCodeLine{00189   \textcolor{keywordtype}{void} checkSpace(\textcolor{keywordtype}{size\_t} sz) \{}
\DoxyCodeLine{00190     \textcolor{keywordflow}{if} (p + sz > buffer + size + extra) \{  \textcolor{comment}{// p>buffer+size}}
\DoxyCodeLine{00191       flush();}
\DoxyCodeLine{00192     \}}
\DoxyCodeLine{00193   \}}
\DoxyCodeLine{00194 }
\DoxyCodeLine{00195   \textcolor{comment}{//************ uint8\_t uint16\_t uint32\_t uint64\_t array *************//}}
\DoxyCodeLine{00196   \textcolor{comment}{/*}}
\DoxyCodeLine{00197 \textcolor{comment}{    The fastest way to write 32k at a time is to write each object into}}
\DoxyCodeLine{00198 \textcolor{comment}{                the buffer as long as it is less than the overflow size.}}
\DoxyCodeLine{00199 \textcolor{comment}{                Then, after writing, if you have filled the buffer, flush}}
\DoxyCodeLine{00200 \textcolor{comment}{                and move the remaining bytes to the beginning of the buffer and}}
\DoxyCodeLine{00201 \textcolor{comment}{    start over.}}
\DoxyCodeLine{00202 \textcolor{comment}{   */}}
\DoxyCodeLine{00203   \textcolor{keywordtype}{void} fastCheckSpace(\textcolor{keywordtype}{size\_t} sz) \{}
\DoxyCodeLine{00204     \textcolor{keywordflow}{if} (p > buffer + size) \{  \textcolor{comment}{// p>buffer+size}}
\DoxyCodeLine{00205       uint32\_t beyondEnd = p -\/ (buffer + size);}
\DoxyCodeLine{00206       flush();}
\DoxyCodeLine{00207       memcpy(buffer, buffer + size, beyondEnd);}
\DoxyCodeLine{00208       p += beyondEnd;}
\DoxyCodeLine{00209       availSize -\/= beyondEnd;}
\DoxyCodeLine{00210     \}}
\DoxyCodeLine{00211   \}}
\DoxyCodeLine{00212 }
\DoxyCodeLine{00213   \textcolor{comment}{//*********************************//}}
\DoxyCodeLine{00214   \textcolor{comment}{//************ uint8\_t uint16\_t uint32\_t uint64\_t array *************//}}
\DoxyCodeLine{00215 }
\DoxyCodeLine{00216   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00217   \textcolor{keywordtype}{void} checkArraySpace(T v[], \textcolor{keywordtype}{size\_t} n) \{}
\DoxyCodeLine{00218     \textcolor{keywordflow}{if} (size < n * \textcolor{keyword}{sizeof}(T)) \{}
\DoxyCodeLine{00219       \textcolor{comment}{// TODO: buffer is not big enough to copy data, write directly}}
\DoxyCodeLine{00220     \}}
\DoxyCodeLine{00221 }
\DoxyCodeLine{00222     \textcolor{comment}{// TODO: efficiency, and for big arrays if (n > ???)}}
\DoxyCodeLine{00223     \textcolor{keywordflow}{if} (availSize < n * \textcolor{keyword}{sizeof}(T)) \{}
\DoxyCodeLine{00224       flush();}
\DoxyCodeLine{00225     \}}
\DoxyCodeLine{00226   \}}
\DoxyCodeLine{00227   \textcolor{comment}{//*********************************//}}
\DoxyCodeLine{00228   \textcolor{comment}{//************ uint8\_t uint16\_t uint32\_t uint64\_t vector *************//}}
\DoxyCodeLine{00229   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00230   \textcolor{keywordtype}{void} checkVectorSpace(\textcolor{keyword}{const} vector<T>\& v) \{}
\DoxyCodeLine{00231     \textcolor{keywordflow}{if} (size < v.size() * \textcolor{keyword}{sizeof}(T)) \{}
\DoxyCodeLine{00232       \textcolor{comment}{// TODO: buffer is not big enough to copy data, write directly}}
\DoxyCodeLine{00233     \}}
\DoxyCodeLine{00234     \textcolor{keywordflow}{if} (availSize < v.size() * \textcolor{keyword}{sizeof}(T)) flush();}
\DoxyCodeLine{00235   \}}
\DoxyCodeLine{00236 }
\DoxyCodeLine{00237   \textcolor{comment}{//*********************************//}}
\DoxyCodeLine{00238   \textcolor{comment}{//************ uint8\_t uint16\_t uint32\_t uint64\_t operator *************//}}
\DoxyCodeLine{00239   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00240   \mbox{\hyperlink{classBuffer}{Buffer}}\& operator<<(T v) \{  \textcolor{comment}{// there is a write in flush function}}
\DoxyCodeLine{00241     checkSpace(\textcolor{keyword}{sizeof}(T));}
\DoxyCodeLine{00242     write(v);}
\DoxyCodeLine{00243     \textcolor{keywordflow}{return} *\textcolor{keyword}{this};}
\DoxyCodeLine{00244   \}}
\DoxyCodeLine{00245 }
\DoxyCodeLine{00246   \textcolor{comment}{/*}}
\DoxyCodeLine{00247 \textcolor{comment}{   TODO: For writing large arrays, it would be more efficient to flush the}}
\DoxyCodeLine{00248 \textcolor{comment}{   buffer, then write directly from the arrays.}}
\DoxyCodeLine{00249 \textcolor{comment}{*/}}
\DoxyCodeLine{00250 }
\DoxyCodeLine{00251   int8\_t \_readI8() \{}
\DoxyCodeLine{00252     int8\_t temp = *(int8\_t*)p;}
\DoxyCodeLine{00253     p += \textcolor{keyword}{sizeof}(int8\_t);}
\DoxyCodeLine{00254     availSize -\/= \textcolor{keyword}{sizeof}(int8\_t);}
\DoxyCodeLine{00255     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00256   \}}
\DoxyCodeLine{00257 }
\DoxyCodeLine{00258   int16\_t \_readI16() \{}
\DoxyCodeLine{00259     int16\_t temp = *(int16\_t*)p;}
\DoxyCodeLine{00260     p += \textcolor{keyword}{sizeof}(int16\_t);}
\DoxyCodeLine{00261     availSize -\/= \textcolor{keyword}{sizeof}(int16\_t);}
\DoxyCodeLine{00262     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00263   \}}
\DoxyCodeLine{00264 }
\DoxyCodeLine{00265   int32\_t \_readI32() \{}
\DoxyCodeLine{00266     int32\_t temp = *(int32\_t*)p;}
\DoxyCodeLine{00267     p += \textcolor{keyword}{sizeof}(int32\_t);}
\DoxyCodeLine{00268     availSize -\/= \textcolor{keyword}{sizeof}(int32\_t);}
\DoxyCodeLine{00269     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00270   \}}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272   int64\_t \_readI64() \{}
\DoxyCodeLine{00273     int64\_t temp = *(int64\_t*)p;}
\DoxyCodeLine{00274     p += \textcolor{keyword}{sizeof}(int64\_t);}
\DoxyCodeLine{00275     availSize -\/= \textcolor{keyword}{sizeof}(int64\_t);}
\DoxyCodeLine{00276     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00277   \}}
\DoxyCodeLine{00278 }
\DoxyCodeLine{00279   int8\_t readI8() \{}
\DoxyCodeLine{00280     checkAvailableRead(\textcolor{keyword}{sizeof}(int8\_t));}
\DoxyCodeLine{00281     \textcolor{keywordflow}{return} \_readI8();}
\DoxyCodeLine{00282   \}}
\DoxyCodeLine{00283 }
\DoxyCodeLine{00284   int16\_t readI16() \{}
\DoxyCodeLine{00285     checkAvailableRead(\textcolor{keyword}{sizeof}(int16\_t));}
\DoxyCodeLine{00286     \textcolor{keywordflow}{return} \_readI16();}
\DoxyCodeLine{00287   \}}
\DoxyCodeLine{00288 }
\DoxyCodeLine{00289   int32\_t readI32() \{}
\DoxyCodeLine{00290     checkAvailableRead(\textcolor{keyword}{sizeof}(int32\_t));}
\DoxyCodeLine{00291     \textcolor{keywordflow}{return} \_readI32();}
\DoxyCodeLine{00292   \}}
\DoxyCodeLine{00293 }
\DoxyCodeLine{00294   int64\_t readI64() \{}
\DoxyCodeLine{00295     checkAvailableRead(\textcolor{keyword}{sizeof}(int64\_t));}
\DoxyCodeLine{00296     \textcolor{keywordflow}{return} \_readI64();}
\DoxyCodeLine{00297   \}}
\DoxyCodeLine{00298 }
\DoxyCodeLine{00299   uint8\_t \_readU8() \{}
\DoxyCodeLine{00300     uint8\_t temp = *(uint8\_t*)p;}
\DoxyCodeLine{00301     p += \textcolor{keyword}{sizeof}(uint8\_t);}
\DoxyCodeLine{00302     availSize -\/= \textcolor{keyword}{sizeof}(uint8\_t);}
\DoxyCodeLine{00303     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00304   \}}
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306   uint16\_t \_readU16() \{}
\DoxyCodeLine{00307     uint16\_t temp = *(uint16\_t*)p;}
\DoxyCodeLine{00308     p += \textcolor{keyword}{sizeof}(uint16\_t);}
\DoxyCodeLine{00309     availSize -\/= \textcolor{keyword}{sizeof}(uint16\_t);}
\DoxyCodeLine{00310     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00311   \}}
\DoxyCodeLine{00312 }
\DoxyCodeLine{00313   uint32\_t \_readU32() \{}
\DoxyCodeLine{00314     uint32\_t temp = *(uint32\_t*)p;}
\DoxyCodeLine{00315     p += \textcolor{keyword}{sizeof}(uint32\_t);}
\DoxyCodeLine{00316     availSize -\/= \textcolor{keyword}{sizeof}(uint32\_t);}
\DoxyCodeLine{00317     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00318   \}}
\DoxyCodeLine{00319 }
\DoxyCodeLine{00320   uint64\_t \_readU64() \{}
\DoxyCodeLine{00321     uint64\_t temp = *(uint64\_t*)p;}
\DoxyCodeLine{00322     p += \textcolor{keyword}{sizeof}(uint64\_t);}
\DoxyCodeLine{00323     availSize -\/= \textcolor{keyword}{sizeof}(uint64\_t);}
\DoxyCodeLine{00324     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00325   \}}
\DoxyCodeLine{00326 }
\DoxyCodeLine{00327   \textcolor{keywordtype}{float} \_readF32() \{}
\DoxyCodeLine{00328     \textcolor{keywordtype}{float} temp = *(\textcolor{keywordtype}{float}*)p;}
\DoxyCodeLine{00329     p += \textcolor{keyword}{sizeof}(float);}
\DoxyCodeLine{00330     availSize -\/= \textcolor{keyword}{sizeof}(float);}
\DoxyCodeLine{00331     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00332   \}}
\DoxyCodeLine{00333 }
\DoxyCodeLine{00334   \textcolor{keywordtype}{double} \_readF64() \{}
\DoxyCodeLine{00335     \textcolor{keywordtype}{double} temp = *(\textcolor{keywordtype}{double}*)p;}
\DoxyCodeLine{00336     p += \textcolor{keyword}{sizeof}(double);}
\DoxyCodeLine{00337     availSize -\/= \textcolor{keyword}{sizeof}(double);}
\DoxyCodeLine{00338     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00339   \}}
\DoxyCodeLine{00340 }
\DoxyCodeLine{00341   uint8\_t readU8() \{}
\DoxyCodeLine{00342     checkAvailableRead(\textcolor{keyword}{sizeof}(uint8\_t));}
\DoxyCodeLine{00343     \textcolor{keywordflow}{return} \_readU8();}
\DoxyCodeLine{00344   \}}
\DoxyCodeLine{00345 }
\DoxyCodeLine{00346   uint16\_t readU16() \{}
\DoxyCodeLine{00347     checkAvailableRead(\textcolor{keyword}{sizeof}(uint16\_t));}
\DoxyCodeLine{00348     \textcolor{keywordflow}{return} \_readU16();}
\DoxyCodeLine{00349   \}}
\DoxyCodeLine{00350 }
\DoxyCodeLine{00351   uint32\_t readU32() \{}
\DoxyCodeLine{00352     checkAvailableRead(\textcolor{keyword}{sizeof}(uint32\_t));}
\DoxyCodeLine{00353     \textcolor{keywordflow}{return} \_readU32();}
\DoxyCodeLine{00354   \}}
\DoxyCodeLine{00355 }
\DoxyCodeLine{00356   uint64\_t readU64() \{}
\DoxyCodeLine{00357     checkAvailableRead(\textcolor{keyword}{sizeof}(uint64\_t));}
\DoxyCodeLine{00358     \textcolor{keywordflow}{return} \_readU64();}
\DoxyCodeLine{00359   \}}
\DoxyCodeLine{00360 }
\DoxyCodeLine{00361   \textcolor{keywordtype}{float} readF32() \{}
\DoxyCodeLine{00362     checkAvailableRead(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{float}));}
\DoxyCodeLine{00363     \textcolor{keywordflow}{return} \_readF32();}
\DoxyCodeLine{00364   \}}
\DoxyCodeLine{00365 }
\DoxyCodeLine{00366   \textcolor{keywordtype}{double} readF64() \{}
\DoxyCodeLine{00367     checkAvailableRead(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double}));}
\DoxyCodeLine{00368     \textcolor{keywordflow}{return} \_readF64();}
\DoxyCodeLine{00369   \}}
\DoxyCodeLine{00370 }
\DoxyCodeLine{00371   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00372   T \_read() \{}
\DoxyCodeLine{00373     T temp = *(T*)p;}
\DoxyCodeLine{00374     p += \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00375     availSize -\/= \textcolor{keyword}{sizeof}(T);}
\DoxyCodeLine{00376     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00377   \}}
\DoxyCodeLine{00378 }
\DoxyCodeLine{00379 \textcolor{preprocessor}{\#if 0}}
\DoxyCodeLine{00380   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00381   T \_readString() \{}
\DoxyCodeLine{00382     \textcolor{keywordtype}{char} length = *p;}
\DoxyCodeLine{00383     \textcolor{keywordtype}{char} word[length + 1];}
\DoxyCodeLine{00384     memcpy(word, p + 1, length);}
\DoxyCodeLine{00385     word[length] = 0;}
\DoxyCodeLine{00386     \textcolor{keywordflow}{return} word;}
\DoxyCodeLine{00387   \}}
\DoxyCodeLine{00388 }
\DoxyCodeLine{00389   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00390   T read() \{}
\DoxyCodeLine{00391     \textcolor{comment}{// cout << (uint64\_t)p << endl;}}
\DoxyCodeLine{00392     checkAvailableRead(\textcolor{keyword}{sizeof}(T));}
\DoxyCodeLine{00393     \textcolor{keywordflow}{return} \_read<T>();}
\DoxyCodeLine{00394   \}}
\DoxyCodeLine{00395 }
\DoxyCodeLine{00396   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00397   T readString() \{}
\DoxyCodeLine{00398     \textcolor{keywordflow}{return} \_readString<T>();}
\DoxyCodeLine{00399   \}}
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401   \textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{00402   \mbox{\hyperlink{classList1}{List1<T>}} readList() \{}
\DoxyCodeLine{00403     uint32\_t len = read<uint32\_t>();}
\DoxyCodeLine{00404     \mbox{\hyperlink{classList1}{List1<T>}} temp(len);}
\DoxyCodeLine{00405     \textcolor{keywordflow}{for} (uint32\_t i = 0; i < len; i++) \{}
\DoxyCodeLine{00406       T val = read<T>();}
\DoxyCodeLine{00407       temp.add(val);}
\DoxyCodeLine{00408       \textcolor{comment}{// TODO: For some reason code does not work without this print statement.}}
\DoxyCodeLine{00409       \textcolor{comment}{// More specifically the endl.}}
\DoxyCodeLine{00410       \textcolor{comment}{// TODO: It appears that this is no longer necessary after the switch to}}
\DoxyCodeLine{00411       \textcolor{comment}{// vector}}
\DoxyCodeLine{00412       \textcolor{comment}{/*std::cout.setstate(std::ios::failbit);}}
\DoxyCodeLine{00413 \textcolor{comment}{      //cout<<temp.getData(i)<<endl;}}
\DoxyCodeLine{00414 \textcolor{comment}{      cout<<"{}"{}<<endl;}}
\DoxyCodeLine{00415 \textcolor{comment}{      std::cout.clear();*/}}
\DoxyCodeLine{00416     \}}
\DoxyCodeLine{00417     \textcolor{keywordflow}{return} temp;}
\DoxyCodeLine{00418   \}}
\DoxyCodeLine{00419 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00420 }
\DoxyCodeLine{00421  \textcolor{keyword}{private}:}
\DoxyCodeLine{00422   \textcolor{keywordtype}{bool} writing;}
\DoxyCodeLine{00423   \textcolor{keywordtype}{bool} isSockBuf = \textcolor{keyword}{false};}
\DoxyCodeLine{00424   \textcolor{keywordtype}{size\_t} size;}
\DoxyCodeLine{00425   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} extra = 128;}
\DoxyCodeLine{00426   \textcolor{keywordtype}{char}* preBuffer;}
\DoxyCodeLine{00427   \textcolor{keywordtype}{char}* buffer;       \textcolor{comment}{// pointer to the buffer}}
\DoxyCodeLine{00428   int32\_t availSize;  \textcolor{comment}{// how much space is left in the buffer}}
\DoxyCodeLine{00429   \textcolor{keywordtype}{char}* p;            \textcolor{comment}{// cursor to current byte for reading/writing}}
\DoxyCodeLine{00430   \textcolor{keywordtype}{int} fd;  \textcolor{comment}{// file descriptor for file backing this buffer (read or write)}}
\DoxyCodeLine{00431   \textcolor{keywordtype}{void} checkAvailableRead(\textcolor{keywordtype}{size\_t} sz) \{}
\DoxyCodeLine{00432     \textcolor{keywordflow}{if} (availSize < sz) \{}
\DoxyCodeLine{00433       \textcolor{keywordtype}{size\_t} overflowSize = availSize;}
\DoxyCodeLine{00434       memcpy(buffer -\/ overflowSize, p, overflowSize);}
\DoxyCodeLine{00435       readNext();}
\DoxyCodeLine{00436       availSize += overflowSize;}
\DoxyCodeLine{00437       p = buffer -\/ overflowSize;}
\DoxyCodeLine{00438     \}}
\DoxyCodeLine{00439   \}}
\DoxyCodeLine{00440   \textcolor{keywordtype}{void} checkAvailableWrite() \{}
\DoxyCodeLine{00441     \textcolor{keywordflow}{if} (p > buffer + size) \{}
\DoxyCodeLine{00442       uint32\_t overflow = p -\/ (buffer + size);}
\DoxyCodeLine{00443       flush();}
\DoxyCodeLine{00444       memcpy(p, p + size, overflow);}
\DoxyCodeLine{00445       p += overflow;}
\DoxyCodeLine{00446       availSize -\/= overflow;}
\DoxyCodeLine{00447     \}}
\DoxyCodeLine{00448   \}}
\DoxyCodeLine{00449   \textcolor{keywordtype}{void} checkAvailableWrite(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* ptr, uint32\_t len) \{}
\DoxyCodeLine{00450     \textcolor{keywordflow}{if} (p + len > buffer + size) \{}
\DoxyCodeLine{00451       memcpy(p, ptr, availSize);}
\DoxyCodeLine{00452       uint32\_t remaining = len -\/ availSize;}
\DoxyCodeLine{00453       flush();}
\DoxyCodeLine{00454       \textcolor{comment}{// TODO: Check if the string is too big!}}
\DoxyCodeLine{00455       memcpy(p, ptr + size, remaining);}
\DoxyCodeLine{00456       p += remaining;}
\DoxyCodeLine{00457       availSize -\/= remaining;}
\DoxyCodeLine{00458       \textcolor{keywordflow}{return};}
\DoxyCodeLine{00459     \}}
\DoxyCodeLine{00460     \textcolor{comment}{// TODO: check case where string is bigger than buffer}}
\DoxyCodeLine{00461     \textcolor{keywordflow}{if} (len > size) \{}
\DoxyCodeLine{00462       flush();}
\DoxyCodeLine{00463       \textcolor{comment}{// TODO: Do something completely different}}
\DoxyCodeLine{00464       ::write(fd, ptr, len);}
\DoxyCodeLine{00465       \textcolor{keywordflow}{return};}
\DoxyCodeLine{00466     \}}
\DoxyCodeLine{00467     memcpy(p, ptr, len);}
\DoxyCodeLine{00468     p += len;}
\DoxyCodeLine{00469     availSize -\/= len;}
\DoxyCodeLine{00470   \}}
\DoxyCodeLine{00471 \};}

\end{DoxyCode}
